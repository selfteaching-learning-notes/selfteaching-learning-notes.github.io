<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[1901020015-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901020015-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：李浩天，只接受三个正确的打开方式 —— 浩天、奇点、战友学号：1901020015 工作背景目前在 互联网+物流 领域深耕，说的高大上一点就是建设中国运输网络主干线。岗位性质更多的集中在经营分析、项目管理、战略研究三个方面 自我介绍一个类数据分析从业者、一个非资深物流人、一个追求成长速率的学生 学习目的最开始的原因其实很简单，想要拾起大学时学习的编程知识。这来源于两个基本诉求： 由于工作的性质，存在外部数据的采集需求，而IT资源又很稀缺，特别是在自己想要研究一些东西的时候。所以想要自己具备一些外部数据的获取能力，可以独立完成 数据爬取 另一个需求是来自于多方面的，想要自己的效率做进一步的提升，并且解锁更多的可能性。比如，工作中可以通过编程替代一部分Excel的工作，更快速的实现一些想法或者编写一个程序完成重复性的内容，脱离 “大表哥” 的困扰 那天我们沟通完之后，关于数据分析的发展方向，我在网上检索了一下，有一篇文章说的最讲究，文章说有四个方向： 业务数据分析(原文就直接叫数据分析，方便理解换了一个名字)：这类基本有两个主要任务：一个是业务数据体系化大白话来说就是业务指标体系的建立，一个是业务问题的解决比如为什么活跃用户数下滑增量放缓等。并且对于传统行业也会存在线下业务的规划包括选址等，会涉及到宏观数据，需要搜索及调研能力。这个岗位貌似说是最适合走向管理岗位的一个职位 数据挖掘： 看下来没有特别明确数据挖掘和数据分析的差别，给我的感觉是数据挖掘貌似更加理论化一些，涉及到模型的建立算法的应用。比如机器学习、协同过滤、关联规则、PageRank 等。在最优化问题的应用上，看到的例子是：外卖行业，如何寻找骑手效率最大化的最优路径 从问题解决的角度基本可以分为几个步骤：问题抽象-&gt;模型建立-&gt;线上部署。在岗位分工上面，问题抽象基本由数据分析完成，模型建立可以是数据分析也可以是数据挖掘，线上部署可以是数据挖掘也可以是数据工程。所以我大致的理解是数据挖掘和数据分析是一脉相承的关系而已，解决的问题难度不同 数据产品：这个现在有两种理解，一种是具备强数据分析能力的PM，一种是公司数据产品的规划者。前者以数据导向优化和改进产品，后者类似于产品经理，主要参与数据相关的产品项目：包括大数据平台、埋点采集系统、BI、推荐系统、广告平台等 数据工程：相对数据挖掘来说更倾向于更底层的工程实现和架构，很多工作是围绕 ETL / DW / BI 进行展开 综合看下来，评估了一下，自己现在应该只涉及到业务数据分析的工作，最开始的诉求也是希望在业务数据分析的路上走的更远一些。可这个并不妨碍那颗数据挖掘的心，关于数据挖掘这里当下有一个比较大的疑问，也希望后续可以得到解答，就是数据挖掘究竟可以解决那些类型的问题，它的边界又在哪里？ 最后特别想说一句感谢。因为最近的自己像是打开了一扇门，当编程、英语以及区块链一个一个迈入自己的视野，感觉自己的眼前像变了一个世界，特别深刻的感受到 “井底之蛙” 的感觉。也因此改变了很多自己的行为，曾经可以忍受的突然就忍受不了了，比如上不了外网 [捂脸笑] 追加一下： 这两天我看完了《自学是一门手艺》的一个链接文章 What exactly can you do with Python? ，就特别想提一个需求：在学习的过程中能不能更多的介绍一下Python在数据分析或者数据挖掘领域有哪些实际的应用场景]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>互联网+物流</tag>
        <tag>追求成长速率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1902100001-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1902100001-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：王学闻 , 大家可以叫我学闻学号：1902100001 工作背景目前从事Java程序员工作(三年工作经验) 自我介绍我是一名在职的Java程序员 , 在这几年的工作中除了敲代码 , 看的最多的就应该是很多所谓的产品经理根据自己的并不实际的调查确定用户的需求 , 然后进行项目开发 , 结果开发的产品犹如石沉大海 , 然后……就没有然后了 . 作为一个底层业务的实现者 , 我深知这种现象在软件开发的普遍性 , 也知道在那些所谓的产品经理眼中用户 “应该” 有的需求是不对的 , 明白这些又怎样 ? 如果换我去做同样的工作 , 或许也会犯一样的难 . 也会一样淹没在无边无际的不确定性之中 . 我想这样的焦虑并不只有我一个人感受得到 . 然而大数据却能解决这样的问题 . 我们可以运用大数据思维去消除不确定性 , 利用它实现精准服务 , 它还能帮我们动态的调整做事策略 , 还能用它去发现未知规律 , 等等等等 . 能够做到让我们的分析更加贴近现实 , 我想大数据思维应该成为每一个有志于在未来数据大潮中过好日子的人的必修课 . 目前的学习阶段 , 初级]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>Java程序员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1902100002-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1902100002-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息 姓名: 苟利桥，当然也有叫大桥的，叫小桥的，等等。 工作背景 目前从事IT工程与运维项目的实施工作，主要是服务器存储以及华为云计算的实施交付于维护相关工作。 自我介绍 虽然岁数不大，30都还差点，但是一路走来一直在学习，从中受益匪浅，我以前大学毕业后是搞基础网络维护与个人pc电脑维保工作的，到后来的企业网维护，企业网IT维护，再到现在的企业网、运营商IT云计算维护。由于我本人背景并不好，所以从技术中获益的幅度更是十分的可观，总是有几句话一直觉得特别受用: 凡事有失有得有得有失，有些事情别人不愿意做的、累的、看不起的可能里面会有机会。 君子性非异也，善假于物也。下面再详述。 为什么想学习数据分析，希望学完之后应⽤在什么场景 这里接着说刚才那句话，像我们很多一线的工程师是骨子里是不乐意搞技术这个东西的，理由很简单就是不受用，性价比很低，毕竟学习技术研究技术非常的花精力，而实际的效益确并不好，这点我自己是深有体会，所以好多一线工程师实际上干的是业务的活，就是变相的搞销售拿提成，真有解决不了的问题，有二线，有研发支持，压根不需要自己花精力去研究。 交代一下背景，更加方便于自己阐述学习的动力和心态。本人一直在工程师岗位那么多年，深刻的认识到技术的重要性，概况起来就两个字效率。同样是做一个事情，我懂技术，我多会那么一些工具，在故障诊断上，工程交付上，思维逻辑上，完全能成指数级的方式改善自己的工作方式，大大提升效率，节约出更多时间来进一步加深扩充技术，从而实现良性循环，量变到达质变，接着而来的就是生活的改变。 话又说回来了，为什么要学习数据分析，是完全因为工作么？显然不是，显然我们工作对数据分析的依赖并不大。如上文讲到，技术改变了我分析问题，看待问题事务的逻辑，提供了我终身学习进步的可能，进而深刻的认识到当下时代从数据中获利的趋势必然会大于我通过工作时间来获利的可能。 好了，上文讲到我们想通过数据来获利，诶就是挣钱，不以挣钱为目的的学习技术那都是耍流氓。 那么我们学完后要干点什么呢： 当然学习数据分析只是我要干的事情中的一部分，就目前我最终想干的事情是通过爬虫、数据分析、信息论、离散数学等，建立一个股票等二级市场涨跌的交易模型，极大概率从中实现获利。 同时，还想通过数据分析，爬取与分析当下的电商平台，比如美团，淘宝，大众点评，链家等等平台的优惠信息以及其他商业价值信息，帮助实现获利决策模型。 最终目的就是从当前的通过完完全全的工作时间获利的模型中解脱出来，创造更多的可能，实现财务自由。 目前自己的学习阶段和疑惑 当然想干那么多事情，单纯只靠数据分析是远远不够的。所以还是要关注当下，沉下心来，一步一个脚印的前进，虽然看过很多书，懂得很多道理，但是我每天依然还是在做调系统、写代码。 因此当下依然还是处在通过代码来调优工作效率的阶段。不过已经能通过爬虫获取到海量数据，存储数据了，所以完全可以进一步进阶来分析这些数据，展现这些价值数据的时候了。 既然如此，那大家就一起共同加油，共渡剩下的阶段吧。 Fighting]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>IT工程运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020008-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901020008-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：王娟芳 【同事叫我芳芳（年龄小的叫芳姐)，大家也可以这么称呼我(✿◡‿◡)】学号：1901020008 工作背景数智校园整体方案解决服务商 自我介绍大家好！作为新兴互联行业与传统教育业的结合体这样一个行业，关于大数据，关于AI，这些前端科技都在时时刻刻影响着我们。 作为商家，一定要成为两个行业的专家才能把路越走越宽。 作为企业主，势必要更快更好的学习，成长，才能不被淘汰。 作为个人，脑中没有对未来清晰的预见，只能让焦虑占据 而作为两个孩子的母亲，教给孩子什么，让孩子走什么样的路，脑子里没有清晰的概念也是不可行的。 关于为什么学习数据分析，我脑中没有一个清晰的定义。一开始进训练营的考虑是：这个世界有方法论，我想找到适合我的，切实可行的方法改变自己无一技之长的现实。后面觉得必须继续学习才能成为一技之长。 现阶段，我只坚定的相信一切都可以通过学习改变。随着学习的深入，也许可以帮我快速入门互联网行业应用于教育界。也许可以帮我理清脑中模糊的人生规划，也许能更清楚地看到未来，给孩子更好的教育。也许还会有更多意外的收获……]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>数智校园</tag>
        <tag>孩子母亲</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050035-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901050035-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：老罗学号：1901050035 工作背景网络维护和管理 自我介绍我是老罗，在广州工作，日常负责网络运行和维护管理工作。工作的老兵，编程的新手，很高兴有机会和大家一起参加数据营学习数据分析和处理，提高工作的效率和自我价值。 ####【为什么想学习数据分析，希望学完之后应⽤在什么场景】 工作20多年，大部分时间以通过系统出告警或用户投诉等传统的方式，来处理网络出现的故障或隐患，工作非常被动；而且随着网络的快速大规模的扩容，现有的人手和手段非常缺乏和落后，希望通过计算机自动收集日志和性能统计数据，分析和评估当前网络运行的状态，以实现对网络运行中的故障自动快速的定位和容量主动精准扩容。 ####【当前的学习阶段和疑惑】 前期参加了自学训练营，初步掌握了Python的程序的运行和基本函数规则等，后续希望通过本期数据营，学会和掌握一套数据分析和处理工具，支撑日常工作，实现对网络系统运行的自动采集、统计和分析，提高管理效率。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>网络维护和管理</tag>
        <tag>编程新手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901070004-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901070004-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：小黎学号：1901070004 工作背景目前工作和普惠金融相关，涉及寻找客户，扶贫贷款发放回收，也涉及社区工作，培养客户良好的卫生健康习惯，普及理财知识等。 自我介绍为什么学习数据分析： 计划从事数据分析工作。 希望学完后应用到什么场景： 可以在新工作中灵活运用学习到的技能，而且可以很好的完成项目，成为一个优秀的数据分析师。 可以迁移分析问题解决问题的能力，让自己成为一个能独立思考的人。目前自己的学习阶段和困惑：完成了自学营初级阶段的学习，MIT的课程还在理解实践中。比较初级。困惑是遇到问题，不知道怎样高效的解决它，怎样使用编程语言去解决问题，不知道背后的思考方式，还有学习到的思考方式怎样落地。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>普惠金融</tag>
        <tag>社区工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010061-自学数据营-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901010061-%E8%87%AA%E5%AD%A6%E6%95%B0%E6%8D%AE%E8%90%A5-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：Music学号：1901010061 工作背景会计 自我介绍我是一名90后南方人，从事玩具行业.为什么想学习数据分析：我对数据分析是没有接触过的，从自已的理解角度，数据分析的作用应该是收集数据信息，然后信息分析，帮助自已作出一些决策判断。我们是处在信息发达的环境，如何取得高质量的信息并学会分析学习。学习数据分析是利大于弊的。学后应用场景： 生活与工作中能使用数据分析来优化决策。学习阶段和疑惑：在几个月前参加了训练营，通过自学，初步认识了python。学完之后，感觉还是有些懵，感觉学完容易忘，不会灵活使用。之后进入到MIT的学习，重新思考了学习这件事情（为什么我学习后的知识容易忘，我应该怎么做，有什么学习方法是适合我的），通过看学习相关的书箱、网上找资料，找到了合适自已学习的方法，目前正在适应中。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>会计</tag>
        <tag>玩具行业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-自学训练营-MIT60001-DAY1]]></title>
    <url>%2FMIT60001%2F1901020043-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT60001-DAY1%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901020043 学习内容：MIT 6.0001 LECTURE 1 +Python 编程导论（第2版）（第1章+第2章的2.1） 学习用时：4小时 学习笔记收获总结： Computers only know what you tell them. Computers only do what you tell them to do. 计算机能且只能做两件事——执行计算与保存计算结果(perform calculations and remember results)，但它把这两件事做到极致。 计算机思维： 七种关系：1.大和小 2.快和慢 3.多维度和单一维度 4.网络和个体 5.自顶向下和自底向上 6.全局和局部 7.成本和表现 两个原则：1.等价性原则 2.模块化原则 ——（吴军的谷歌方法论） 算法：是一个有穷指令序列，描述了这样一种计算过程，即在给定的输入集合中执行时，会按照一系列定义明确的状态进行，最终产生一个输出结果。（简单步骤，控制流，何时结束） 通用图灵机：可以接受任意一个图灵机 M 的编码 ，然后模拟 M 的运作。 邱奇-图灵论题：任何在算法上可计算的问题同样可由图灵机计算。（如果一个函数是可计算的，那么一定可以通过对图灵机进行编程实现这种计算。） 停机问题：是否存在一个程序P，对于任意输入的程序w，能够判断w会在有限时间内结束或者死循环。 图灵完备性：在可计算性理论里，如果一系列操作数据的规则（如指令集、编程语言、细胞自动机）可以用来模拟单带图灵机，那么它是图灵完备的。图灵完全性通常指“具有无限存储能力的通用物理机器或编程语言”,所有现代编程语言都是图灵完备的。 每种编程语言都有基本结构、语法、静态语义和语义。 Python的基本结构包括字面量和中缀操作符；语法定义了字符和符号组成句子的正确形式；静态语义定义了哪些语法有效的句子是有意义的；语义为每个语法正确又没有静态语义错误的句子关联一个含义。 程序如果没有正确运行，就应该表现出明显的错误。只要有可能，我们都应该以这种方式编写程序。 对象是Python程序处理的核心元素。Python有4类标量对象：int，float，bool，None 在Python中，变量仅是名称，没有其他意义（非常重要）。变量名可以包含大写字母、小写字母、数字（不能以数字开头）和特殊字符_，变量名称大小写敏感，保留字不能做变量名。 恰当的选择变量名和添加注释是提高程序可读性的好方法。 总结：看英文字幕虽然很难但是不会像中文字幕令人不舒服；明确计算机的边界，能做什么，不能做什么；学习计算机思维的相关知识很重要，得到有很多文章讲解，应该再看一些相关书籍；个人偏好一些概念的认真理解，会额外耗费很多时间，是否有用在以后的学习中会验证；养成好的编程习惯，先从变量名和注释开始；多输入代码，刻意练习的技巧可以考虑如何用在这里。遇到的难点与问题（是否解决）：对停机问题的理解还不够，先放放，过一周再看。]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901020043-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901020043-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：金志坚学号：1901020043 工作背景医药行业，从事营销推广工作 自我介绍今年42岁，除了日常的管理工作所需，最想学好的就是英语和编程，一法通万法通，通过学习编程提高自己的自学能力，希望能保持终身学习的能力，也希望能给员工展示一切皆有可能，年龄不是问题。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>医药行业</tag>
        <tag>营销推广</tag>
        <tag>年龄不是问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090043-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901090043-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：姜翔学号：1901090043 工作背景在上海从事过医药行业，金融期货行业，目前在家大部分时间学习，小部分时间在老家江西开发业务 自我介绍 我叫姜翔，之前从事过医药，金融行业，目前在老家有个办公室，生意一般，想寻求其他方面的突破。 之前有点编程基础，不想抛掉这门手艺，想重新拾取，加上Python的强大，高效，对数据分析，人工智能也有兴趣，而在这两个方面Python都有一定的优势。俗话说艺多不压身，也是想离校之后重新系统的学习一门课程，增强自学的信心，这很重要。 毕业到目前为止已有7年了，时间转瞬即逝，比起无聊的社交，真正用心的沉浸在一门手艺当中，这是让时间眷顾的最好方法了，每天坚持，沉浸其中，你会发现日子似乎过的没那么快了，心里获得的充实感和安慰是巨大的，我想每个成人都应该长期保持这种状态。而编程是比较容易获得所谓心流体验的，这是编程作为热门自学课程的原因之一。 我想了下，入门这么多年，应该是已经入门了，入门学习的最核心的字符串、整数类型、浮点类型、函数、类、模块、DIG、复杂度和数据结构都有一定的掌握，希望在之后进阶路上进一步加强理论和实践，做到不断挑战高要求，不断进步。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>医药行业</tag>
        <tag>自由职业者</tag>
        <tag>金融销售业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901060005-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901060005-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：代智国学号：1901060005 工作背景企业经营者 自我介绍我叫代智国来自深圳，2002年大学毕业，2004来到深圳，恍恍惚惚，蓦然回首已经在深圳生活了15年。10年前开始创业，现在是一名中小企业老板，从事餐饮食材贸易，开设连锁餐厅。团队的慢慢成熟，自己的自由时间相对宽裕一点，有时会迷茫、焦虑甚至迷失。未来是什么样子？现在的自己能够适应未来吗？怎样才能更好的读懂未来、适应未来。。。。。。通过一个线上学习APP订阅了笑来老师的《通往财富自由之路》，对自己的很多认知有了很大的触动和颠覆。追随笑来老师来到了Python自学营，下定决心挑战自己。想到笑来老师说过： 你原本有机会，却因为害怕羞耻而放弃…… 最终，你一无所成，当然应该羞耻。 为了不让自己一无所成，要坚定也坚持的将Python学习进行到底。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>中小企业老板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050081-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901050081-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：QQ学号：1901050081 工作背景待业（无特定行业） 自我介绍作为一名 80 后待业大龄女青年，学习编程是为了使自己更快的适应巨变的社会，获得一个长期奋斗的方向。再选择数据分析作为进阶学习，以求先掌握一门技术作为谋生手段，并学会如何透过现象看清本质，在数据中获得最有价值的信息，不被表象迷惑，做出最有利于自我的长远决策。期望可以通过不断打磨自己的技艺，靠自己的双手过上自己喜欢的生活，由自己掌握的时间和节奏，不再活在别人设定的框架中。 目前学习阶段和学习困惑现阶段已经完成了入门训练营和 MIT 视频公开课的学习，还在继续了解 Python 的语言特性。不知道初高中数学都丢光了，数据分析能学得好吗？是不是先学会爬虫，再学习数据分析师会好一些？还是直接挑战数据分析师呢？要系统的学习，还需要学习哪些课程会更好呢？]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>待业大龄女青年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050119-自学训练营学习7群-Python入门]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901050119-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A07%E7%BE%A4-Python%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[姓名：王银/Galaxy 学号：1901050119 学习内容：Python 14 天入门 学习用时：46.5h 每一个概念都不简单，“自学”更是如此经验基础先介绍一下我的个人经验基础。在填课前问卷的时候，我选的是学过一种语言，做过demo程序。其实，选这一项只是因为没有更贴切的选项。其实我学过好几种语言，只是没有一种达到精通的。 我很早就对编程感兴趣，然而，这个“早”只是相对的，事实上发现的有点晚，高考填志愿的时候我执拗地选择了物理专业，而后才发现新大陆……那又怎样，我是兴趣驱动型的，我要自学编程，我要考研转专业……所以，从本科开始学C语言，我就把学校发的清华那本教材翻来覆去学了很多遍，当时根本没想到可以多买几本书对照着看，直到后来参加工作用C语言写代码，也没想着添置新的参考书。不知道自己不知道的时候，真可怕！ 后来，我又执拗地按照自己的意愿行事，考了电路与系统专业的研究生，离计算机近了些，然后利用实习的机会，又自学C++，当然有“同事老师”可以咨询，学的应该还凑合，因为，当我应聘软件工程师的时候，如愿拿到两份外企的Offer，一个是北京的C++语言，一个是西安的C语言。后来，我去了西安的公司。大家做的不是从无到有的工作，只能算作模块化编程吧，在原有代码的基础上增添、修改功能，不需要自己搭建编程环境。所以，我那一本教材上的内容也够用了，因此也没长出新的本事，没有被迫学会整套技能。后来，也学了一些html、css、C#，但都比较肤浅，没有走得很远。究其原因，还是自己的操作系统太陈旧，而又不知道可以升级造成的。 查漏补缺那份工作持续了４年多，我辞职回家了，一边带孩子一边瞎折腾。直到《自学是门手艺》又让重新点燃了我的编程热情。这一次，不为给别人打工，就想掌握这门手艺，为己所用。 早在3月份我就报了自学训练营，因为自己本来自由时间就不够充裕，担心无法在规定时间内配合作业学完书上的内容，而且对于搭建环境不太擅长，所以特意选了比较靠后的班次，给自己留足时间去攻关。可是，学而不用、学而不练，加上学习时间不紧凑，总是前学后忘，所以，直到开营一本书还是没有完整通读下来。 我用亲身经历证明，搭建环境真的非常摧残信心！我在开营前专门留出四五天时间通关，耗费很多精力，折磨死大批脑细胞……所幸最终基本上突围成功。正因为经历了这般艰辛的未雨绸缪，自学营前两天搭建环境和熟悉工具的作业才得以“轻松”完成，也算是对之前职业生涯的查漏补缺。 在训练营学习和自己死磕的最大区别就是，这里针对每一个难点，都有对应的文档资料可以参考，你不必大海捞针碰运气，不用一头雾水干着急，顺着图例的指引前进就对了，再不行，还有战友可以交流，实在搞不定，还有教练指点迷津……总之，再也不用冤死脑细胞，你一定能一路走下去……从这个角度望过去，我之前的“未雨绸缪”多少有点惨烈。如果再给我一次重新选择的机会，我宁愿不要那么“睿智”。 因为前期已经花了大量时间来搭建、配置环境，遇到的问题基本上已经解决了。所以Day2作业的主要时间都用来学习文档。之前毫无头绪地照着书上的指示配置，成功了就庆幸，失败了就焦急，根本不知所以然，心里完全没底。 回过头来学习文档，思路逐渐清晰，明白了那些命令的含义，最重要的是，知道了如何按需配置，终于从苍蝇模式过渡到蜜蜂模式。由此深刻体会到，参加训练营的最大意义，其实就是面对陌生地形，可以直接获得精准图例，迅速了解全貌。跳过苍蝇模式，直接开启蜜蜂模式，然后，循着光飞过去就是了。 基础知识应用回过头来看，自学营的整个作业体系设计得很精巧。先是熟悉工具、搭建环境，然后从打印一个最简单的“Hello World!”开始，让大家通过实现一个个简单而完整的功能把Python用起来，然后选取一个很实用主题层层递进。让大家亲身体会同样一个功能，如何一步步扩充、一步步改进，从简陋到完善，从笨拙到讲究，一步一步见证成长。 Day3看文档差不多花了5个小时，感觉实现计算器的逻辑应该很简单，本来想独立完成，但是，对Python的编程规则还不太熟悉，而且太久没写代码了，真的要动手时，居然又无从下手。真切感受到从0到1的艰难，于是Google了一个范例，又参阅了一位学友放在issue里的代码，总算可以下笔了。 先大概写出核心功能，然后不断尝试优化，这个过程中渐入佳境。因为工具用的不熟练，Jupyter lab和VS两边交替调试，走了不少弯路，不过，功夫不负有心人，最后终于实现了自己比较满意的效果。 Day4看文档1小时，独立写代码并调试1小时，感觉越来越得心应手。虽然还不能一气呵成，但是已经知道各种困惑应该去哪里查资料，进而顺利解决问题，每天都感觉到进步。 Day5深刻体会到在用中学和单纯用眼睛“学”的巨大差异了。看书的时候，感觉努努力都能看得懂，似乎明白该怎么用了。但是要写代码的时候，根本不是信手拈来啊，反复来回不停地翻文档，每一遍都有新收获。文档解决不了的问题，就问Google，总有前人留下的足迹，任何时候都不孤单。 Day5的任务知识覆盖面比较广，需要融会贯通，交叉使用，感受到了不同概念之间是如何产生联系的，终于体会到为什么笑来老师说《自学是门手艺》是《通往财富自由之路》的实践版了。 完成Day6作业之前，先把字符串相关内容仔细复习整理了一遍，认真做了笔记，又发现了不少仅仅靠阅读没能深入理解的内容，眼过千遍不如手过一遍！做作业倒是没用多少时间，但是感觉程序通用性不强，暂时却无力改进。后面很多内容还没看，温故知新，一步一个脚印，慢即是快。 Day7作业距离上次时间间隔有点长，因为我之前一直没能把书看完。第一部分好不容易看完了，到后面看着看着感觉前面的内容已经没什么印象了，所以，这次趁着边用边学，及时做笔记，让看过的内容都连贯起来。用纸笔记笔记收获很大。 本以为Day8的作业很简单，结果做的过程中困难重重。对于错误和异常的触发机制、对应的分类以及处理方式理解太粗浅，搞得自己摸不着头脑，乱试一通，代码编辑器用的也不熟练，加了断点忘记取消了，多亏教练指点，思路终于逐渐清晰，这只是个开始，目测前面埋伏还很多…… Day9大部分时间花在打开并读取json文件上了，查了很多资料，也浏览了学友们的作业，怎么试都不行。我也曾怀疑文件是空的，但是Windows无法直接打开，我又不知道也没想到用vscode就能打开json文件，结果文件果然是空的，我却以为是出错了，白费了很多功夫。经教练指点，终于顺利完成作业。感悟：对行家来说的常识，往往却是新手凭一己之力无法逾越的坎儿。这个好像不好补～ Day10作业耗时最多的地方其实是上一次隐藏的一个bug，只不过没影响到结果，所以没有发现。上次替换无用字符的时候，对于数字字符，想要进行统一处理，用这样的语句 if text[i] in range(1, 321) 跳过，不加到字典里。 今天采取同样的方法，没有得到预期效果，很纳闷，调好了很久，终于发现症结，其实文档里面的数字都被识别为字符了，那句代码根本没起作用。最后，还是老老实实继续用很笨的方式解决问题。 消化这本书感觉就像探索社会主义道路一样曲折，前进中还会有反复、还会有倒退。分明看的时候好像都懂了，但是走着走着，知识点之间串联不起来了，因此举步维艰，感觉只是把眼前的文字识别出来毫无意义，就只好从头来过。但是，仅靠眼睛形成的记忆是靠不住的，反复忘，太不牢固。直到开始用纸笔做笔记，之前与之擦肩而过的、想当然的一些知识点终于理解到位了。虽然只是把书上的很多内容抄到本子上，但是这个过程就是很神奇，收获的是仅靠阅读无法达到的高度。 生活场景拓展从Day11开始用真实场景演练了，之前只是人造应用场景。这两天的作业主题选取的是用机器人管理微信消息的应用场景，不能再贴近生活了！就像在试卷上答题和将所学应用于实践解决实际生活问题的区别一样，难度不是一个数量级了。如果没有作业单上的代码示例，只看文档是没法完成任务的，网上也很难找到合适的例子。 DAY12作业虽然已经提交，但是还有点疑惑。感觉实践作业不像之前的基础作业，做完了确实就知道是怎么回事儿了。实践作业如果没有参考根本完成不了。在一个项目文件里搜寻所需的零散信息，然后拼装起来实现一个完整而具体的功能，又一次手足无措。我们缺失的是什么，如何弥补呢？全面阅读文档，归纳、总结、融会贯通的能力不是一朝一夕练就的，但只要坚持、反复实践，总有功成的一天。 Day13作业又拖了好久，也没刻意计时。多多少少心里有点抵触情绪，感觉怎么看文档都只是一知半解，不如前面的基础作业有成就感，所以积极性不高。 最终下定决心照着教程把代码敲出来，因为之前看过文档，多少理解了一些，再自己敲一遍确实比只用眼睛看理解更深刻了。还有些不够明朗的细节留着以后慢慢消化吧。 由图例到实地曾经，我也是个“弄潮儿”，看不上的老师，怕被误导，上课睡觉，下课自学，成绩也还不错。所以，我以为自己很擅长自学并引以为豪，直到见识了自学高手的境界，才意识到自己所谓的“自学”只不过是很初级的阶段，前方还有很长的路要走，我却以为已经到达目的地了。这认知简直太误人了。 14天的训练营虽然要告一段落了，但这只是个起点，才刚刚学会看图例而已，千里之行只迈出了第一步。下一步继续研读《自学是门手艺》，随时查阅官方文档，进行关键知识点的总结、归纳、整理、组织，不断完善更新，直至刻在脑子里。同时不间断地练手，必须学以致用，否则只能永远停留在纸上谈兵的水平。 实地考察更有趣、更挑战、更刺激。手握地图，至少不会误入歧途。再出发，已经不是独自开荒了。路径清晰、路标醒目，就连远处的风景都依稀可见…… 如果说用代码实现一个计算器、一个九九乘法表什么的，对我们的生活改观并不大，那么写段代码管理微信消息，是一件多么高大上又体面的事情啊！微信几乎是每个人生活的一部分，不难想象，精通Python将如何改善我们的日常生活……用个不那么恰当的比喻：手里拿着锤子的人，看什么都是钉子。掌握一项技能就是拥有一种工具，用得顺手了，就停不下来了……期待那一天早早到来！]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050017-自学训练营学习4群-PYTHON入门]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901050017-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A04%E7%BE%A4-PYTHON%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学员信息 姓名：王晓镜 学号：1901050017 学习内容：14天python入门营 学习用时：40小时 学习笔记我选择的是预约制学习，可以自己学完一次作业以后马上申请学习后面的作业。 训练营带给我的 训练营的每日作业都会迫使我主动思考，逼迫我一字一句去阅读要求，不按照要求做就会完不成作业，强制改正了我阅读不仔细的问题。 社群式学习。不是单打独斗地面对困难，‘恐惧未知’这条恶龙不会在大脑中盘旋很久，因为有教练和同学在帮助着我，即使偶尔会深陷泥沼，只要我呼喊，他们就会立刻施于援手。学习效率大大提高。 养成了阅读官方档案的习惯。这一点非常重要，每天的作业都会给出官方档案的链接，在群里大家也会互相提醒，随时巩固这个好习惯。 学会了程序员思考，遇到难点，学会把它分成一小段一小段来解决，并且用自己熟知的知识尝试类比来解释给自己听。 深刻地认识到了借鉴优秀程序员的智慧结晶是非常重要的，有质量的输出的前提是要有质量地输入，如果能看懂优质代码，并为己用，这本身就是一种进步。 千里之行，始于足下—-训练营第一天 day1-day2作业完成自学训练营最能反映学习中不好的习惯。 收到“自学任务清单”，开始学习。清单表达的很清楚，但真的就是我看不见它，它一直在那里。清单里要求先看参考资料，我愣是自动掠过这一步，现在想来，真的是很佩服我的大脑，就这样习惯性地怕麻烦，找捷径，试图略过一切，然后还妄想能快速完成作业。 我在卡壳以后，冷静了下来，重新从清单1开始看，耐心地看了参考资料，认真地对待每一句话，这样竟然神奇地解决了每一个问题。这次我认识到想要解决问题，还是得克服自己的毛病。在做作业时，踏踏实实。 因为习惯不好，没有阅读官方文件。在一个小到不能再小的步骤上卡壳了1个小时。 在查看社群其他人的聊天中，找到了解决方案，在第一天截止时间前完成了第一天的打卡。 好久没体会过沉浸的感觉了，就是那种猛一抬头，一个小时过去了。 第一天的学习让我认识到想要解决问题，还是得克服自己的毛病。在做作业时，要踏踏实实。 纸上得来终觉浅，绝知此事须躬行—-训练营第二天 day3-day5作业完成看到群里的同学都在陆续地交作业（社群学习的好处，时刻督促自己），我停掉了“自我攻击的剧情”，心里开始接受一件事，那就是遇到不会的问题时是正常的，不久的将来一定会熟练掌握的。于是，心理突破了，脑子和手并用，完成作业的速度就提上来了。再加上，我不再以借鉴代码为耻，目的就是为了学习，我再借鉴的基础上再加上自己的理解，现在已经能够写出代码的一大部分了。自主学习加同学间互助式学习，具像化了李笑来老师说的： 很多人有莫名其妙的误解，以为“自学”（self-learning)就一定是“自己独自学”（solo-learning)，殊不知，自学也需要社交。 别怕！ 啥也别怕！没什么可怕的！ 收获总结： 学会了抄代码。不再谴责自己没用，心安理得地抄了三种代码，然后运行，改写代码，最后改写出了自己的代码。 敢于调试，以前总是怕出现问题，手心冒汗，后背冒汗，脑袋发麻，如今出现问题我就搜索问题是什么意思，然后冷静地去想办法解决。 学会去github里的issues找问题答案。 读书破万卷，下笔如有神—-训练营第三天 day6作业完成收获总结： 行之有效的方法就是大量阅读官方资料，因为是社群学习+github分布式交作业，所以可以看到很多同学的代码。学习+模仿，是我在3天时间内完成day1-6的任务的秘诀。输入有质量才是最好的进步方式。 读书不觉已春深，一寸光阴一寸金—-训练营第四天 day7-day10作业完成写python代码，做有用之事。在第四天，完成到了训练营day10的任务。 收获总结： 因为这几天的学习，让我深刻体会到了废寝忘食、孜孜不倦、目不转睛、聚精会神、茶饭不思的境界，心流时间可以达到3、4个小时不间断。 对阅读更是有了新的体会：一字不落的读，来回反复地读，不躲避，不放弃，迎着困难读。 对官方文档更加看重，对google也更加依赖，李笑来老师说的好： 学习任何东西，首先看官方文档或产品说明书，那些学习高手都是会先阅读官方文档的人。 能google出答案的问题，就不需要去麻烦别人.google、stackoverflow、wikipedia、youtube这都是自学人经常要去搜索的好地方。 千里之行，始于足下—-训练营第五天 day11-day12作业完成 眼是懒汉，手是好汉不怕，一点也不可怕，不难，一点也不难。 在这天，我清楚地感受到今天不想做作业地心情，抵触、逃避、恐慌、焦虑。。。。。。因为预知了困难，提前看GitHub 上的issues里都是关于day11作业的困惑和疑问，心里多少有些抵触。但是我知道只有做了才能解决，而不是空想。逃避没有任何用，把任务分解，一句话一句话地去实施。 随着着手敲代码的开始，这一天没有想象中困难，最后完成了day11-12的任务。 收获总结： 深刻理解了，写代码如同搭积木，一个函数如同一块乐高积木，只要一块一块加上去，就具像化了自己的目标。 一直听说python爬虫技术，今天终于得以实施，抓去了张小龙的演讲稿并做了处理，返回了邮件。 一直听说微信机器人，今天又亲自实施，和微信好友互动有无，她给我文章，我给她文章的数据，是自动的哦。 这次我好像真的很可以确信，学python不会再半途而废了，也许日后如同excel一样，用的机会越来越多了。 咬定青山不放松—-训练营第六天 day13作业未完成距离上一次提交作业已经过了两天，因为这次遇到了问题。求助issues和助教，还是未能解决。matplot绘制图表在我的电脑中显示不出来。无解中。 敏而好学，不耻下问—-训练营第7天 day13-14作业完成在google和其他同学的作业中寻找到答案，遇到两个大问题最终解决。1、matplot绘制图表在我的电脑中显示不出来。刚开始我以为代码没写对，后来用官方文档里的作业依然显示不出来。我才想到可能是其他问题，因为不自信，所以才会在代码上改了又改，耽误了时间，而真正问题不能解决。这是因为matplotlib的backend设置成了agg格式得在整个代码前加上 12import matplotlibmatplotlib.use（’TkAgg’) 而且要注意要在import matplotlib.pyplot前使用。2、微信返回数据乱码a.去fontplace下载SimHei字体，其他也可以。但网页打不开，我就选择了科学的方法，一次ok。b.把这个ttf文件手动添加到matplotlib的mpl_data里的tff文件夹里，这里都是已装字体。c.找到matplotlibrc文件，打开，这是不要害怕，直接找到font.sans-serif，在冒号后面打出：SimHei。关闭文件。在代码里添加 12from pylab import mplmpl.rcParams[‘font.sans-serif’] = [‘SimHei’] 事情到此，我的代码已经完全能显示了，并且中文也出来了。而且最重要的是通过此次的问题解决，让我对这次的作业代码非常熟悉，已经能变换地写出好几种相同功能的代码了。也算是有所收获。 最终的一天来到了，全部学完了训练营的任务，中间有困惑，有惊喜，最终收获的是满满的知识和弥足珍贵的自学体验，升级了自学的操作系统，对未来编程技能的使用充满了信心。]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050017-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901050017-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：王晓镜学号：1901050017 工作背景中学老师 自我介绍我叫王晓镜。 学习python是想活在未来，用代码来为自己工作，用程序员思维来思考，用数据分析来判断形势和做出选择。 目前python入门营已学完，MIT课程自学已完成，正准备进入python进阶营学习。 我选择进入python入门营学习是做过最正确的选择，我发现与其说是学习写代码，不如说是如何学习程序员式思考方式。在紧张、有条不紊地14天学习过后，我看到了python的库的丰富，对于数据的抓取和可视化都不复杂，稍加学习就能掌握基本的数据读写和作出图表。但我知道代码易抄，背后却需要自己的思考和扎实的知识基础。我分析了自己对数据分析的兴趣，是源于想从看似复杂难辨的原始数据中找出事实，以让人一目了然的方式展现出来，从而基于事实作出判断。无论我的工作上还是业余生活上都非常需要这个技能，工作上我作为教务处老师，整天和成绩打交道，这是原始数据，并不需要抓取，但目前为止，只能用Excel展现学生成绩，而老师的教学质量和学生的成绩都无法关联，我先用python帮助自己；在其他方面，我想抓取我感兴趣的金融、时事数据并作出分析，这也需要python来帮助我。自学是可以的，但我在入门营体会到了自学社交的魅力，所以在开设进阶数据营后，我就来报名了。希望能让自己梳理好关于数据分析的系统思维，掌握数据分析的技能，随着学习的深入，对于自己想要的应用也许能更加细分化。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>中学老师</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901100009-自学是门手艺-第一部分的七个章节]]></title>
    <url>%2F%E8%87%AA%E5%AD%A6%E6%98%AF%E9%97%A8%E6%89%8B%E8%89%BA%2F1901100009-%E8%87%AA%E5%AD%A6%E6%98%AF%E9%97%A8%E6%89%8B%E8%89%BA-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E7%9A%84%E4%B8%83%E4%B8%AA%E7%AB%A0%E8%8A%82%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901100009 学习内容：《自学是门手艺》 学习用时：60min 学习笔记 刚刚完成14天自学营的学习。针对一些疑问也跟教练做了一些交流。了解到了学习Python早期就是要多看代码，多输入才能多输出。自学营毕业了算是入门了，后面几天继续阅读《自学是门手艺》以了解整本书的框架。 今天阅读了《自学是门手艺》的第一部分的七个章节。相比其他的计算机教程书，笑来老师的这本书阅读起来更加友好一些。了解了Python的一些最基本的知识。同时对自学营早期的一些作业内容，通过阅读书籍也多了一层理解。 很快理解函数从另外一个角度看只不过是 “程序员作为用户所使用的产品”。]]></content>
      <categories>
        <category>自学是门手艺</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010056-自学训练营学习1群-Python入门]]></title>
    <url>%2FPython%E5%85%A5%E9%97%A8%2F1901010056-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A01%E7%BE%A4-Python%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[学员信息 姓名：马林同学 学号：1901010056 学习内容：Python 14 天入门 学习用时：总用时110.2小时 学习笔记day1~day14的记录day1学习时长:7个小时 学习内容 创建了两个自己的代码仓库，学会使用branch 和pull requst 在Github的仓库提交issue 通过Github Desktop 将ma-hellow-world 仓库克隆到了本地电脑 将公共作业的仓库克隆到了本地电脑，在本地仓库的exercises目录下藏剑文件 通过Github桌面客户端将本第电脑的变更推送到自己的账户下的作业仓库 向远程作业仓库的master分支发起了pull request 收获 pull request are zhe heart of the collaboration shows diffs or differences of the content from both branch make adn commit changes 和open a pull request for changes to the develop和merge your pull request 在三个步骤在初期的时候搞不明白 认识了不少单词和句子 在找按钮的过程中，经常忽略下拉找找 对于一些难词很多的生词，可以直接字典翻译，提高效率 day2学习时长:7个小时 收获 锻炼自己，通过找、 问的方式去解决问题。 顺利下载并安装了Anaconda，并在其界面安装了VScode，Jupyter Notebook 和 JupyterLab. 在 vscode 中配置 Python 环境选择特定环境，应该输入“Python: Select Interpreter”进行选择。但一直没有对应的选项。通过糖总发总的issue链接找到答案。要搜索“language”——“Configure Display Language”——将”locale”:”en”修改为”locale”:”en-US”，保存。重启。 用jupiter note book 阅读笑来老师新书，被网页上的一个烟雾弹，所困住。经过助教点播，才解决，发现也不是大问题。 day3学习时长:4个小时 收获 在自己的编码器上跑出程序 由于认真看过笑来老师的新书，再结合google翻译，看起来英文文档还比较顺畅，但是一下子也没好好吸收 感悟 实际的操作代码很多都是可以从网上找到的。这对于初步阶段的我很有利用价值。 用好google和google 翻译，似乎没有什么事是解决不了的 day4学习时长:6个小时 遇到问题 当拿到题时，没有任何头绪。知道会用到条件判断和循环语句，但是不知道怎么用。最后在issue上解决了问题 在写代码时忘了加冒号，导致运行失败 在写while语句时，发现空格也非常重要，否则，程序是没办法成功的 感悟 细心也非常重要 把学的内容解释，可以在代码中加井号，解释出来，加深理解 day5学习时长:9.5个小时 学习内容 字符串的基本处理，将文本里的单词进行替换，剔除不想要的单词，翻转单词中的大小写字母 用字典统计字符串样本中英文单词出现的次数，按照出现次数从大到小进行排列，注意排除符号 将数组顺序进行翻转，用字符符串切片方式取出第三到第八个字符，将获得的字符进行翻转，将结果转化成整型，分别转化成二进制，八进制，十六进制 学习笑来老师书上的内容，知道了笑来老师书的代码是可以直接在lab上直接运行的操作，并且可以改着玩 将单词中包含ea的单词除去的时候，一开始参考用del但是后面的怎么跑都不成功。后来又参考另外几名同学的作业，和issue，才知道del 的用途一般用来删除数组中的一个元素，或者删除一个变量 感悟 day5的实用性很强，有四六级或者考研的所有的卷子text,就可以对里面所有的单词出现的频率进行统计，从而把时间都花在记忆高频率不会的单词上，只是最后转化成二进制，八进制，十六进制，暂时还不知道有什么用 在打代码的时候，需要注意冒号是否打了 可以把笑来老师的书提上日程上来，对于增加对python有很大帮助，上面的代码可以直接修改，对于无论是函数，数据类型，还是其中的逻辑关系的理解都又很大的帮助 程序跑错误后的提示，也至关重要，提示里的单词一定要明白意思 似乎是上点门道了。结合笑来老师的书，提供了很多的方便 day6学习时长:5个小时 学习内容 封装统计英文单词词频的函数。这个任务是基于昨天 的内容 封装统计中文汉字字频的函数，判断是不是汉字这个问题需要一定的时间 感悟 虽然作业时做下来了，但是作业里面还是有很多东西一知半解，无论是函数的运用，还是字符的形式，等等一系列内容都是需要加强训练的，都是需要时间和精力的投入才能慢慢上手的 已经完成的同学的作业也是有好有坏，有的非常的简洁，有的非常的繁琐，再参考的时候一定要多看几个，比较一下 day5的Python中的禅宗中的这句话”面对困惑，拒绝猜测的诱惑”给自己提了个醒，不要懒的查找就去猜测函数的功能或者不会的内容 day7学习时长:10.5个小时 感悟 冥想对于编程来说有很大的帮助，因为无论是调试一个程序，还是阅读一段自己理解的概念，都能够让自己很清楚很客观认识自己的现状，自己的处境，自己正在挣扎在一个怎样的问题上。缺乏元认知能力的话，很容易陷入低级的困惑当中，甚至即使过了很长时间自己的对问题的思考都得不到推进。 做题的时候，可以把笔记本就打开，遇到不会的问题，就敲到上面，遇到自己不熟悉的知识点就敲到上面。因为不会的都是需要自己加强的，所以敲一遍一点都不过分，甚至多敲几遍都不过分 在把笑来老师的part1再看一遍，发现这一部分需要多看几遍，不然不容易掌握，多看一遍对全局都有一个更深刻的理解 把对英文的词频和中文的字频包装成一个函数，需要的时候随时调用，这样真的剩了不少事 知识点总结 循环语句可能带有一个else子句；这个else子句它会在循环遍历完列表的时候被执行（另一种情况暂时没遇到先不讨论），但是不会在循环被break语句终止时被执行。 break 它也属于一个子句中的一个条件，表示跳出最近的for循环，（while没遇到暂时不讨论），控制流程往下跑。但是一种情况比较特殊就是往下跑的时候遇到else语句，此时else语句不被执行 琢磨流程控制中的break和continue需要时间多点。continue语句看官方文档稍微好理解，就是当条件被满足时，也就是continue被执行时，流程被控制往上跑，继续上面的循环 易错点 在mydouble文件夹的同级目录下，创建main.py文件。意思就文件夹mydouble和文件main.py都出现在同一个页面中，容易犯的误区就是，看到，一个文件夹，一个文件，想当然地认为这个文件就在文件夹里。 day8学习时长:3.7个小时 学习收获 Ctrl +Backspace是删除整个单词 Ctrl+左右移动键是光标来回在整个单词间跳动 Tab +右移动键 可以自动补全函数和前面已经输入过的字符 感悟 尝试一下，通过写的方式将自己的思想过程具体化，避免失去重点，让任务得不到推进。 一切提升效率的东西都要尽快第掌握 day9学习时长:11.5个小时 卡点 不知道怎么把VS code给玩坏了，以前的所有作业的程序都运行不了，但是发现前已经花了好多时间在上面这是第一个卡点，卡了我不少时间，最后在折腾不行，听教练的建议又重新安装了一遍，随后才正常运转 关于tang300.json路径的设置，我一直担忧是自己的运行系统是C盘，但是作业在D盘的原因，在参考前辈的作业，什么情况都有，况且每个人的路径都不一样，苦苦挣扎，也卡了不少时间，最后在YouTube上的相关视频找到启发，让程序给运行成功了 在找问题的时候，由把本地文件的仓库的文件位置给变动了，所以就是在desktop上费了点时间 感悟 累坏了，不过在通过自己的努力查找，让程序运行成功的一瞬间，感觉自己的真牛，差点都认怂了，幸好没放弃，充足的时间预算也相当重要， day 10学习时长:11个小时 下载完jieba不知道怎样安装，在issue上虽然有个方法，但是在终端输入指令根本不会，在教练逯彬杨的帮助下，又查阅相关的资料解决 程序死活运行不了，以前的做的有的也运行不了，教练协助，修改了部分代码，还是不行，尝试了，各种办法以后（有一个尝试把操作页面改成中文了），为下一步发现问题铺一步路，尝试到11点，和辅导员老白的聊天中，他提了一句，配置问题，然后第二天发现有一个bug确实是配置问题，以前做的能运行了 找不到路径问题，由于前段时间，一不小心玩坏了本地，删除了以后，导致路径发现问题，后来又把程序中的路径改了过来 程序运行找不到mydoule中的stats_world，最后索性都在后面加了一个数字，最后终于成功 感悟 做的时候，不知道是以前的坑，还是现在的坑在等着你，让你去跳，要做多就是找出坑，把它填平，确保自己不会掉下去。 时间预算也是非常重要的考虑因素，如果时间预算不充裕的话，做这个难度还确实不小 主动性也是一个十分重要的因素，卡到一个部分，查完后还一脸懵逼，就问一下，教练十分敬业的帮助你，旁敲侧击地地提醒你，都会帮你把作业给往下推进。但是，前提是，你的主动性得强，关键在你自己。 day11学习时长:20个小时 卡点 安装文档解析库，折腾了一波 用requests请求公众号文章连接，获取返回结果response,把微信公众号的正文提取出来 开通邮箱这个权限后，输入的不是邮箱密码而是授权码，而且输入的位置是在终端 最后是在自己的邮箱先测试，反复第想 感悟 里面的步骤一步一步来，一步成功后，在继续下面的步骤，比如print出来，看这一步成功后再进行一步，避免问题堆积 想起一首歌词，“这一路上走走停停，顺着少年漂流的痕迹”，因为事比较多，所以自学这个也是挺艰难的，这几天都是，做做停停，不过只要不放弃，就有机会，如果放弃了，那这件事肯定凉凉。 辅导员和教练，助教的存在真的很重要，虽然培养的是自学能力，但是如果只靠自己而不去向前辈请教，我自己肯定做不到并且极其容易放弃，我想很多人肯定也做不到，所以有什么困惑，多和他们交流交流，收获绝对是很大的 day12学习时长:5.5个小时 卡点 安装wxpy,显示需要升级pip，根据提示输入指令后，又出现安装环境错误，直接把错误复制，在百度中搜索后，根据简书上的提示，进行改写，又出现错误。然后发现，在升级pip 的时候的命令少写一个数字，填上后，错误消失，在cmd 中查看晒否安装wxpy成功，成功后继续下一步 在终端测试得回来的数据不显示 自动接受的文章，把参考资料的延申都大致看完后，参考实例代码，运行琢磨，发现需要，把最后的embed（）函数也剪切过来，才能检验前几段程序，可是还是没解决问题，又在网上转一圈后，在何教练的点播下，又改了一行代码，解决 文本出现了，但是，词频没出现，经过琢磨后， 发现把stats_word11名字，改一下，解决 感悟 在卡点三花费时间最长，最后教练一句话解决，教练的重要性，不言自明 作业是作业，但是相关的衍生工作，都够自己的琢磨一整子的，就比如今天的wxpy: 用 Python 玩微信 也刚好在室友的帮助下，调试很多遍成功，相关实用性的训练有时需要求助的不止一个人 经过这段时间的思考，认为，自学的常态是，碰到问题，明确问题，想办法解决问题。其中最为关键的是想办法解决问题，相关论坛的，内网和外网，教练们，等等，想各种渠道去解决问题。 day13学习时长:3.5个小时 卡点 参考matplotlib的资料，将day12中的结果生成一张图片，将演示代码直接复制能出现一样的图片结果&gt;现在想办法在这个代码改改，把day12的结果想办法引进来 将返回给好友的内容以表的形式出现，参考作业代码不行，通过百度，直接把上面的结果转化成list形式，可以返回给好友 感悟 day13新增的部分更像是一个工具，一个将表格转换成图片的工具，将里面的东西稍微变变型就能弄出自己的东西 day14学习时长:6个小时 感悟 这一路走过来，像极了过关的游戏的感觉，你会遇到各种各样的卡点，不要怕，那是进步过关的入口 最后还是要感谢教练、辅导员、助教的帮助和鼓励，才让我有能力、有信心、有勇气去与困难做斗争，去把时间当朋友，披荆斩浪，勇往直前。]]></content>
      <categories>
        <category>Python入门</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学营</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010056-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901010056-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：马林学号：1901010056 工作背景大学狗 自我介绍 自我介绍:有一年七个月时长的时间记录者，这个习惯加速了自己的进步，所以很多场合都很想说两句，希望大家可以一块时间记录，加速成长。最后也非常高兴认识大家，希望能互相学习，互相帮助，互相鼓励，共同进步。 我学习Python的目的目前是为了将来的工作加筹码，“独善其身”完了以后，希望可以“平天下”，哈哈说得有点大了，目前希望用途： 可以用在对Python领域工作岗位的分析上 对自己的两本时间记录数据的分析上 如果时间记录分析出的各项数据，能给自己带来清楚的认知以及未来计划的优良改善的话，我希望可以将功能落地，组建一个社群去帮助更多伙伴养成时间记录，分析时间记录的好习惯。 目前的学习阶段：Python入门营的学习内容，MIT入门课，Python相关书籍的阅读 疑惑：Python的细分领域下实际的工作内容有哪些？学员所学的内容有没有对平时的学习工作立即产生帮助的例子？]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自学数据营</tag>
        <tag>大学生</tag>
        <tag>农学专业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050119-自学是门手艺(1.5.2)-Day18]]></title>
    <url>%2F%E8%87%AA%E5%AD%A6%E6%98%AF%E9%97%A8%E6%89%8B%E8%89%BA%2F1901050119-%E8%87%AA%E5%AD%A6%E6%98%AF%E9%97%A8%E6%89%8B%E8%89%BA-1-5-2-Day18%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901050119 学习内容：《自学是门手艺》- 1.5.2 值及其相应的运算 学习用时：1.5h 学习笔记收获总结先把书读厚再读薄，试着借用作者的视角，通过归纳、总结，复现每一部分内容的知识结构。最后，还要能再次把书读厚。如果能做到像作者那样去思考，那么，头脑中提炼出的知识结构就可以随时还原，就像根据目录检索正文一样。这样，一本书就彻底消化吸收了。 Daily Tips 这一章主要介绍了基础数据类型的运算细节。而除了基础数据类型，我们需要由它们组合起来的更多复杂数据类型。但无论数据的类型是什么，被操作符操作的总是该数据的值。 值是程序的基础成分（Building blocks） 常量的值就是它们字面所表达的值。变量必须先赋值才能使用，即，要先把一个值保存到变量中，它才能在其后被运算。 在 Python 中每个函数都有返回值，默认返回 None 既然有不同类型的数据，它们就分别对应着不同类型的值。通常相同类型的值才能相互运算。在不得不对不同类型的值进行运算之前，总是要事先做 Type Casting（类型转换）。 函数就相当于各种事先写好的子程序，给它传递一个值，它会对其进行运算，而后返回一个值（最起码返回一个 None）。 每个变量或者常量，除了它们的值之外，同时还相当于有一个对应的布尔值。]]></content>
      <categories>
        <category>自学是门手艺</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>学习打卡</tag>
        <tag>自学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901050119-自我介绍]]></title>
    <url>%2F%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F1901050119-%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[基本信息姓名：Galaxy学号：1901050119 工作背景全职妈妈+自由职业者 自我介绍先介绍一下我的个人经验基础。在填课前问卷的时候，我选的是学过一种语言，做过demo程序。其实，选这一项只是因为没有更贴切的选项。其实我学过好几种语言，只是没有一种达到精通的。 我很早就对编程感兴趣，然而，这个“早”只是相对的，事实上发现的有点晚，高考填志愿的时候我执拗地选择了物理专业，而后才发现新大陆……那又怎样，我是兴趣驱动型的，我要自学编程，我要考研转专业……所以，从本科开始学C语言，我就把学校发的清华那本教材翻来覆去学了很多遍，当时根本没想到可以多买几本书对照着看，直到后来参加工作用C语言写代码，也没想着添置新的参考书。不知道自己不知道的时候，真可怕！ 后来，我又执拗地按照自己的意愿行事，考了电路与系统专业的研究生，离计算机近了些，然后利用实习的机会，又自学C++，当然有“同事老师”可以咨询，学的应该还凑合，因为，当我应聘软件工程师的时候，如愿拿到两份外企的Offer，一个是北京的C++语言，一个是西安的C语言。后来，我去了西安的公司。大家做的不是从无到有的工作，只能算作模块化编程吧，在原有代码的基础上增添、修改功能，不需要自己搭建编程环境。所以，我那一本教材上的内容也够用了，因此也没长出新的本事，没有被迫学会整套技能。后来，也学了一些html、css、C#，但都比较肤浅，没有走得很远。究其原因，还是自己的操作系统太陈旧，而又不知道可以升级造成的。 那份工作持续了４年多，我辞职回家了，一边带孩子一边瞎折腾。直到《自学是门手艺》又让重新点燃了我的编程热情。这一次，不为给别人打工，就想掌握这门手艺，为己所用。]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>全职妈妈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet2(Part2)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet2(Part3)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 2 (ZIP) 打卡天数：D07 Part 3 作业:A. 游戏要求: 程序必须从 words.txt 文件中随机挑选一个单词。hangman.py 文件中已经实现了加载单词列表 和 随机选择单词 的功能。 用户一开始有6次机会 游戏一开始，提示用户有单词中有多少个字母，提示用户的机会次数。 程序需要判断用户还有哪些字母可以猜 B. 用户交互:The game must be interactive and flow as follows: 每次在用户猜测之前，你需要显示以下信息： a. 提示用户所剩的次数 b. 还有哪些字母用户还没有猜测 提示用户每次只能猜一个字母 每次等用户输入后，需要告诉用户所输入的单词是否在单词中 等用户输入后，你还需要显示结果，哪些才对哪些还没有猜到，使用下划线来标识没有猜到的字母位置。 最后，输出(­­­­­)符号，用户区分每一轮游戏 C. 用户输入要求： 你可以假设用户每次只输入一个字符，但用户也许会输入数字、特殊符号、字母，你的程序只接收小写字母 如果用户输入了字母意外的内容，你需要告诉用户只能输入字母。每当用户输入非字母字符、或者已经输入过的字母，将会减少一次警告的机会，如果没有了警告机会，游戏就会结束。 可以灵活运用一下函数： str.isalpha(‘your string’) str.lower(‘Your String’) D. 游戏规则 初始【警告次数【为3 如果用户输入了非字母的内容，【警告次数】减一；没有警告次数，游戏失败 如果用户输入了已经输入过的内容，【警告次数】减一 ； 辅音：如果用户输入了辅音字母，且没有猜中，【猜测机会】减1 元音：如果用户输入的原因字母，没有猜过，且没有猜中，【猜测机会】减2 E. 游戏终止条件 当用户猜对了所有字母 或者 次数消耗完时终止游戏 次数消耗完并且没有完成字母，告诉用户结果并显示正确的字母。 用户赢了的话，输出恭喜信息，并显示用户分数 Total score = guesses_remaining* number unique letters in secret_word（总分 = 剩余猜测次数 x 单词字母数（去重）） 作业心得 学习 not in list 的写法 list去重的方法 enumerate 的使用 程序代码（完成提示功能）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377# Problem Set 2, hangman.py# Name: # Collaborators:# Time spent:# Hangman Game# -----------------------------------# Helper code# You don't need to understand this helper code,# but you will have to know how to use the functions# (so be sure to read the docstrings!)import randomimport stringWORDLIST_FILENAME = "words.txt"def load_words(): """ Returns a list of valid words. Words are strings of lowercase letters. Depending on the size of the word list, this function may take a while to finish. """ print("Loading word list from file...") # inFile: file inFile = open(WORDLIST_FILENAME, 'r') # line: string line = inFile.readline() # wordlist: list of strings wordlist = line.split() print(" ", len(wordlist), "words loaded.") return wordlistdef choose_word(wordlist): """ wordlist (list): list of words (strings) Returns a word from wordlist at random """ return random.choice(wordlist)# end of helper code# -----------------------------------# Load the list of words into the variable wordlist# so that it can be accessed from anywhere in the programwordlist = load_words()def is_word_guessed(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; assumes all letters are lowercase; 用户需要猜的单词，假设所有字母都是小写 letters_guessed: list (of letters), which letters have been guessed so far; assumes that all letters are lowercase; 用户已经猜过的字母列表 returns: boolean, True if all the letters of secret_word are in letters_guessed; False otherwise; 如果 secret_word 的字母，都在 letters_guessed 中，返回 True，否则返回 False ''' for letter in secret_word: if letter not in letters_guessed: return False return Truedef get_guessed_word(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; 用户需要猜的单词 letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string, comprised of letters, underscores (_), and spaces that represents which letters in secret_word have been guessed so far. ''' res = "" for letter in secret_word: if letter not in letters_guessed: res += "_ " else: res += letter return resdef get_available_letters(letters_guessed): ''' letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string (of letters), comprised of letters that represents which letters have not yet been guessed. 返回目前还没有猜过的字母 ''' res = "" for letter in string.ascii_lowercase: if letter not in letters_guessed: res += letter return resdef score_counter(guesses_remaining, secret_word): '''计算分数 guesses_remaining: 剩余可猜单词的次数 secret_word: 要猜测但单词 ''' return guesses_remaining * len(list(set(list(secret_word))))def hangman(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Remember to make sure that the user puts in a letter! * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. Follows the other limitations detailed in the problem write-up. ''' print("Welcome to the game Hangman!") print("I am thinking of a word that is &#123;&#125; letters long.".format(len(secret_word))) warnings_remaining = 3 print("You have &#123;&#125; warnings left..".format(warnings_remaining)) letters_guessed = [] guesses_remaining = 6 available_letters = string.ascii_lowercase current_guessed_word = get_guessed_word(secret_word, letters_guessed) VOWELS = ['a', 'e', 'i', 'o', 'u'] # while guesses_remaining &gt; 0: while True: if is_word_guessed(secret_word, letters_guessed): # 整个单词都猜对了 print("Congratulations, you won!") total_score = score_counter(guesses_remaining, secret_word) print("Your total score for this game is: &#123;&#125;".format(total_score)) exit() elif guesses_remaining &lt;= 0: print("Sorry, you ran out of guesses. The word was: &#123;&#125;".format(secret_word)) exit() print("-------------") print("You have &#123;&#125; guesses left.".format(guesses_remaining)) print("Available letters: &#123;&#125;".format(available_letters)) letter = input("Please guess a letter: ").lower() if not letter.isalpha(): if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! That is not a valid letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue # 判断用户输入的字母，之前是否输入过 if letter in letters_guessed: if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! You've already guessed that letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue letters_guessed.append(letter) current_guessed_word = get_guessed_word(secret_word, letters_guessed) if letter in secret_word: print("Good guess: &#123;&#125;".format(current_guessed_word)) else: # 没有猜对 if letter in VOWELS: guesses_remaining -= 2 else: guesses_remaining -= 1 print("Oops! That letter is not in my word: &#123;&#125;".format(current_guessed_word)) available_letters = get_available_letters(letters_guessed)# When you've completed your hangman function, scroll down to the bottom# of the file and uncomment the first two lines to test#(hint: you might want to pick your own# secret_word while you're doing your own testing)# -----------------------------------def match_with_gaps(my_word, other_word): ''' my_word: string with _ characters, current guess of secret word other_word: string, regular English word returns: boolean, True if all the actual letters of my_word match the corresponding letters of other_word, or the letter is the special symbol _ , and my_word and other_word are of the same length; False otherwise: ''' my_word = my_word.replace(' ', '') if len(my_word) == len(other_word): hidden_letters = [] for i,c in enumerate(my_word): if c == other_word[i]: continue elif c == '_': hidden_letters.append(other_word[i]) else: return False for hidden_letter in hidden_letters: if hidden_letter in my_word: return False return True else: return False def show_possible_matches(my_word): ''' my_word: string with _ characters, current guess of secret word returns: nothing, but should print out every word in wordlist that matches my_word Keep in mind that in hangman when a letter is guessed, all the positions at which that letter occurs in the secret word are revealed. Therefore, the hidden letter(_ ) cannot be one of the letters in the word that has already been revealed. ''' my_word = my_word.replace(' ', '') possible_matches = [] for word in wordlist: if match_with_gaps(my_word, word): possible_matches.append(word) print(" ".join(possible_matches))def hangman_with_hints(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Make sure to check that the user guesses a letter * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. * If the guess is the symbol *, print out all words in wordlist that matches the current guessed word. Follows the other limitations detailed in the problem write-up. ''' print("Welcome to the game Hangman!") print("I am thinking of a word that is &#123;&#125; letters long.".format(len(secret_word))) warnings_remaining = 3 print("You have &#123;&#125; warnings left..".format(warnings_remaining)) letters_guessed = [] guesses_remaining = 6 available_letters = string.ascii_lowercase current_guessed_word = get_guessed_word(secret_word, letters_guessed) VOWELS = ['a', 'e', 'i', 'o', 'u'] # while guesses_remaining &gt; 0: while True: if is_word_guessed(secret_word, letters_guessed): # 整个单词都猜对了 print("Congratulations, you won!") total_score = score_counter(guesses_remaining, secret_word) print("Your total score for this game is: &#123;&#125;".format(total_score)) exit() elif guesses_remaining &lt;= 0: print("Sorry, you ran out of guesses. The word was: &#123;&#125;".format(secret_word)) exit() print("-------------") print("You have &#123;&#125; guesses left.".format(guesses_remaining)) print("Available letters: &#123;&#125;".format(available_letters)) letter = input("Please guess a letter: ").lower() if not letter.isalpha(): if letter == '*': print("Possible word matches are:") show_possible_matches(current_guessed_word) continue if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! That is not a valid letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue # 判断用户输入的字母，之前是否输入过 if letter in letters_guessed: if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! You've already guessed that letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue letters_guessed.append(letter) current_guessed_word = get_guessed_word(secret_word, letters_guessed) if letter in secret_word: print("Good guess: &#123;&#125;".format(current_guessed_word)) else: # 没有猜对 if letter in VOWELS: guesses_remaining -= 2 else: guesses_remaining -= 1 print("Oops! That letter is not in my word: &#123;&#125;".format(current_guessed_word)) available_letters = get_available_letters(letters_guessed)# When you've completed your hangman_with_hint function, comment the two similar# lines above that were used to run the hangman function, and then uncomment# these two lines and run this file to test!# Hint: You might want to pick your own secret_word while you're testing.if __name__ == "__main__": # pass # To test part 2, comment out the pass line above and # uncomment the following two lines. # secret_word = choose_word(wordlist) # secret_word = 'else' # hangman(secret_word)############### # To test part 3 re-comment out the above lines and # uncomment the following two lines. secret_word = choose_word(wordlist) secret_word = 'tact' hangman_with_hints(secret_word)]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901010000-MIT-自学 MIT 原版书 第三章]]></title>
    <url>%2FMIT60001%2F1901010000-MIT-%E8%87%AA%E5%AD%A6-MIT-%E5%8E%9F%E7%89%88%E4%B9%A6-%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[学员信息 学号：1901010000 学习内容：自学 MIT 原版书 第三章一些简单的数值程序/其他补充阅读材料 学习用时：60min 学习笔记 完成30天打卡后，首次来完成当周打卡任务。发现Python健脑最好别间隔太久，要不一回来看就又觉得有丢丢陌生 这章其实就还是在继续复习while循环和for循环的基本编写方式。喜欢书里的写法，每次讲解完程序就会写”有经验的程序员一般是这样做的”。里面有一个例子是程序会永远运行下去，因为循环体没有减少两个参数之前的差距。经验丰富的程序员经常会插入一些print语句，比如测试递减函数是否真的递减。 这也是优秀教练的教法，比如今天我看到蔡教练给姜翔发的google工程师的编写规范·。下面也也发给大家一起参考。 看到特别好玩的三个语录分享给大家一乐： 这个”电话”有太多缺点，没法当作真正的通信手段。这东西本身对我们没有价值。 ——西联公司1976年内部备忘录 我看全世界对计算机的需求量总共可能只有五台。 ——托马斯沃森，IBM董事长，1943年 没有任何理由能够证明，人人都想在家里拥有一台计算机。 ——肯奥尔森，DEC公司总裁和创始人，1977年]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet2(Part1)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet2(Part1)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 2 (ZIP) 打卡天数：D05 Part 1 作业要求（简述）:A. 游戏要求: 程序必须从 words.txt 文件中随机挑选一个单词。hangman.py 文件中已经实现了加载单词列表 和 随机选择单词 的功能。 用户一开始有6次机会 游戏一开始，提示用户有单词中有多少个字母，提示用户的机会次数。 程序需要判断用户还有哪些字母可以猜 B. 用户交互:The game must be interactive and flow as follows: 每次在用户猜测之前，你需要显示以下信息： a. 提示用户所剩的次数 b. 还有哪些字母用户还没有猜测 提示用户每次只能猜一个字母 每次等用户输入后，需要告诉用户所输入的单词是否在单词中 等用户输入后，你还需要显示结果，哪些才对哪些还没有猜到，使用下划线来标识没有猜到的字母位置。 最后，输出(­­­­­)符号，用户区分每一轮游戏 C. 用户输入要求： 你可以假设用户每次只输入一个字符，但用户也许会输入数字、特殊符号、字母，你的程序只接收小写字母 如果用户输入了字母意外的内容，你需要告诉用户只能输入字母。每当用户输入非字母字符、或者已经输入过的字母，将会减少一次警告的机会，如果没有了警告机会，游戏就会结束。 可以灵活运用一下函数： str.isalpha(‘your string’) str.lower(‘Your String’) D. 游戏规则 初始【警告次数【为3 如果用户输入了非字母的内容，【警告次数】减一；没有警告次数，游戏失败 如果用户输入了已经输入过的内容，【警告次数】减一 ； 辅音：如果用户输入了辅音字母，且没有猜中，【猜测机会】减1 元音：如果用户输入的原因字母，没有猜过，且没有猜中，【猜测机会】减2 E. 游戏终止条件 当用户猜对了所有字母 或者 次数消耗完时终止游戏 次数消耗完并且没有完成字母，告诉用户结果并显示正确的字母。 用户赢了的话，输出恭喜信息，并显示用户分数 Total score = guesses_remaining* number unique letters in secret_word（总分 = 剩余猜测次数 x 单词字母数（去重）） 作业心得 学会 not in list 的写法 程序代码（完成三个基本辅助函数）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217# Problem Set 2, hangman.py# Name: # Collaborators:# Time spent:# Hangman Game# -----------------------------------# Helper code# You don't need to understand this helper code,# but you will have to know how to use the functions# (so be sure to read the docstrings!)import randomimport stringWORDLIST_FILENAME = "words.txt"def load_words(): """ Returns a list of valid words. Words are strings of lowercase letters. Depending on the size of the word list, this function may take a while to finish. """ print("Loading word list from file...") # inFile: file inFile = open(WORDLIST_FILENAME, 'r') # line: string line = inFile.readline() # wordlist: list of strings wordlist = line.split() print(" ", len(wordlist), "words loaded.") return wordlistdef choose_word(wordlist): """ wordlist (list): list of words (strings) Returns a word from wordlist at random """ return random.choice(wordlist)# end of helper code# -----------------------------------# Load the list of words into the variable wordlist# so that it can be accessed from anywhere in the programwordlist = load_words()def is_word_guessed(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; assumes all letters are lowercase; 用户需要猜的单词，假设所有字母都是小写 letters_guessed: list (of letters), which letters have been guessed so far; assumes that all letters are lowercase; 用户已经猜过的字母列表 returns: boolean, True if all the letters of secret_word are in letters_guessed; False otherwise; 如果 secret_word 的字母，都在 letters_guessed 中，返回 True，否则返回 False ''' for letter in secret_word: if letter not in letters_guessed: return False return Truedef get_guessed_word(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; 用户需要猜的单词 letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string, comprised of letters, underscores (_), and spaces that represents which letters in secret_word have been guessed so far. ''' res = "" for letter in secret_word: if letter not in letters_guessed: res += "_ " else: res += letter return resdef get_available_letters(letters_guessed): ''' letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string (of letters), comprised of letters that represents which letters have not yet been guessed. ''' res = "" for letter in string.ascii_lowercase: if letter not in letters_guessed: res += letter return resdef hangman(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Remember to make sure that the user puts in a letter! * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. Follows the other limitations detailed in the problem write-up. ''' # FILL IN YOUR CODE HERE AND DELETE "pass" pass# When you've completed your hangman function, scroll down to the bottom# of the file and uncomment the first two lines to test#(hint: you might want to pick your own# secret_word while you're doing your own testing)# -----------------------------------def match_with_gaps(my_word, other_word): ''' my_word: string with _ characters, current guess of secret word other_word: string, regular English word returns: boolean, True if all the actual letters of my_word match the corresponding letters of other_word, or the letter is the special symbol _ , and my_word and other_word are of the same length; False otherwise: ''' # FILL IN YOUR CODE HERE AND DELETE "pass" passdef show_possible_matches(my_word): ''' my_word: string with _ characters, current guess of secret word returns: nothing, but should print out every word in wordlist that matches my_word Keep in mind that in hangman when a letter is guessed, all the positions at which that letter occurs in the secret word are revealed. Therefore, the hidden letter(_ ) cannot be one of the letters in the word that has already been revealed. ''' # FILL IN YOUR CODE HERE AND DELETE "pass" passdef hangman_with_hints(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Make sure to check that the user guesses a letter * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. * If the guess is the symbol *, print out all words in wordlist that matches the current guessed word. Follows the other limitations detailed in the problem write-up. ''' # FILL IN YOUR CODE HERE AND DELETE "pass" pass# When you've completed your hangman_with_hint function, comment the two similar# lines above that were used to run the hangman function, and then uncomment# these two lines and run this file to test!# Hint: You might want to pick your own secret_word while you're testing.if __name__ == "__main__": # pass # To test part 2, comment out the pass line above and # uncomment the following two lines. secret_word = choose_word(wordlist) hangman(secret_word)############### # To test part 3 re-comment out the above lines and # uncomment the following two lines. #secret_word = choose_word(wordlist) #hangman_with_hints(secret_word)]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet2(Part2)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet2(Part2)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 2 (ZIP) 打卡天数：D06 Part 2 作业:A. 游戏要求: 程序必须从 words.txt 文件中随机挑选一个单词。hangman.py 文件中已经实现了加载单词列表 和 随机选择单词 的功能。 用户一开始有6次机会 游戏一开始，提示用户有单词中有多少个字母，提示用户的机会次数。 程序需要判断用户还有哪些字母可以猜 B. 用户交互:The game must be interactive and flow as follows: 每次在用户猜测之前，你需要显示以下信息： a. 提示用户所剩的次数 b. 还有哪些字母用户还没有猜测 提示用户每次只能猜一个字母 每次等用户输入后，需要告诉用户所输入的单词是否在单词中 等用户输入后，你还需要显示结果，哪些才对哪些还没有猜到，使用下划线来标识没有猜到的字母位置。 最后，输出(­­­­­)符号，用户区分每一轮游戏 C. 用户输入要求： 你可以假设用户每次只输入一个字符，但用户也许会输入数字、特殊符号、字母，你的程序只接收小写字母 如果用户输入了字母意外的内容，你需要告诉用户只能输入字母。每当用户输入非字母字符、或者已经输入过的字母，将会减少一次警告的机会，如果没有了警告机会，游戏就会结束。 可以灵活运用一下函数： str.isalpha(‘your string’) str.lower(‘Your String’) D. 游戏规则 初始【警告次数【为3 如果用户输入了非字母的内容，【警告次数】减一；没有警告次数，游戏失败 如果用户输入了已经输入过的内容，【警告次数】减一 ； 辅音：如果用户输入了辅音字母，且没有猜中，【猜测机会】减1 元音：如果用户输入的原因字母，没有猜过，且没有猜中，【猜测机会】减2 E. 游戏终止条件 当用户猜对了所有字母 或者 次数消耗完时终止游戏 次数消耗完并且没有完成字母，告诉用户结果并显示正确的字母。 用户赢了的话，输出恭喜信息，并显示用户分数 Total score = guesses_remaining* number unique letters in secret_word（总分 = 剩余猜测次数 x 单词字母数（去重）） 作业心得 学习 not in list 的写法 list去重的方法 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293# Problem Set 2, hangman.py# Name: # Collaborators:# Time spent:# Hangman Game# -----------------------------------# Helper code# You don't need to understand this helper code,# but you will have to know how to use the functions# (so be sure to read the docstrings!)import randomimport stringWORDLIST_FILENAME = "words.txt"def load_words(): """ Returns a list of valid words. Words are strings of lowercase letters. Depending on the size of the word list, this function may take a while to finish. """ print("Loading word list from file...") # inFile: file inFile = open(WORDLIST_FILENAME, 'r') # line: string line = inFile.readline() # wordlist: list of strings wordlist = line.split() print(" ", len(wordlist), "words loaded.") return wordlistdef choose_word(wordlist): """ wordlist (list): list of words (strings) Returns a word from wordlist at random """ return random.choice(wordlist)# end of helper code# -----------------------------------# Load the list of words into the variable wordlist# so that it can be accessed from anywhere in the programwordlist = load_words()def is_word_guessed(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; assumes all letters are lowercase; 用户需要猜的单词，假设所有字母都是小写 letters_guessed: list (of letters), which letters have been guessed so far; assumes that all letters are lowercase; 用户已经猜过的字母列表 returns: boolean, True if all the letters of secret_word are in letters_guessed; False otherwise; 如果 secret_word 的字母，都在 letters_guessed 中，返回 True，否则返回 False ''' for letter in secret_word: if letter not in letters_guessed: return False return Truedef get_guessed_word(secret_word, letters_guessed): ''' secret_word: string, the word the user is guessing; 用户需要猜的单词 letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string, comprised of letters, underscores (_), and spaces that represents which letters in secret_word have been guessed so far. ''' res = "" for letter in secret_word: if letter not in letters_guessed: res += "_ " else: res += letter return resdef get_available_letters(letters_guessed): ''' letters_guessed: list (of letters), which letters have been guessed so far; 目前猜过的字母 returns: string (of letters), comprised of letters that represents which letters have not yet been guessed. 返回目前还没有猜过的字母 ''' res = "" for letter in string.ascii_lowercase: if letter not in letters_guessed: res += letter return resdef score_counter(guesses_remaining, secret_word): '''计算分数 guesses_remaining: 剩余可猜单词的次数 secret_word: 要猜测但单词 ''' return guesses_remaining * len(list(set(list(secret_word))))def hangman(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Remember to make sure that the user puts in a letter! * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. Follows the other limitations detailed in the problem write-up. ''' print("Welcome to the game Hangman!") print("I am thinking of a word that is &#123;&#125; letters long.".format(len(secret_word))) warnings_remaining = 3 print("You have &#123;&#125; warnings left..".format(warnings_remaining)) letters_guessed = [] guesses_remaining = 6 available_letters = string.ascii_lowercase current_guessed_word = get_guessed_word(secret_word, letters_guessed) VOWELS = ['a', 'e', 'i', 'o', 'u'] # while guesses_remaining &gt; 0: while True: if is_word_guessed(secret_word, letters_guessed): # 整个单词都猜对了 print("Congratulations, you won!") total_score = score_counter(guesses_remaining, secret_word) print("Your total score for this game is: &#123;&#125;".format(total_score)) exit() elif guesses_remaining &lt;= 0: print("Sorry, you ran out of guesses. The word was: &#123;&#125;".format(secret_word)) exit() print("-------------") print("You have &#123;&#125; guesses left.".format(guesses_remaining)) print("Available letters: &#123;&#125;".format(available_letters)) letter = input("Please guess a letter: ").lower() if not letter.isalpha(): if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! That is not a valid letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue # 判断用户输入的字母，之前是否输入过 if letter in letters_guessed: if warnings_remaining &gt; 0: warnings_remaining -= 1 else: guesses_remaining -= 1 print("Oops! You've already guessed that letter. You have &#123;&#125; warnings left: &#123;&#125;".format(warnings_remaining, current_guessed_word)) continue letters_guessed.append(letter) current_guessed_word = get_guessed_word(secret_word, letters_guessed) if letter in secret_word: print("Good guess: &#123;&#125;".format(current_guessed_word)) else: # 没有猜对 if letter in VOWELS: guesses_remaining -= 2 else: guesses_remaining -= 1 print("Oops! That letter is not in my word: &#123;&#125;".format(current_guessed_word)) available_letters = get_available_letters(letters_guessed)# When you've completed your hangman function, scroll down to the bottom# of the file and uncomment the first two lines to test#(hint: you might want to pick your own# secret_word while you're doing your own testing)# -----------------------------------def match_with_gaps(my_word, other_word): ''' my_word: string with _ characters, current guess of secret word other_word: string, regular English word returns: boolean, True if all the actual letters of my_word match the corresponding letters of other_word, or the letter is the special symbol _ , and my_word and other_word are of the same length; False otherwise: ''' # FILL IN YOUR CODE HERE AND DELETE "pass" passdef show_possible_matches(my_word): ''' my_word: string with _ characters, current guess of secret word returns: nothing, but should print out every word in wordlist that matches my_word Keep in mind that in hangman when a letter is guessed, all the positions at which that letter occurs in the secret word are revealed. Therefore, the hidden letter(_ ) cannot be one of the letters in the word that has already been revealed. ''' # FILL IN YOUR CODE HERE AND DELETE "pass" passdef hangman_with_hints(secret_word): ''' secret_word: string, the secret word to guess. Starts up an interactive game of Hangman. * At the start of the game, let the user know how many letters the secret_word contains and how many guesses s/he starts with. * The user should start with 6 guesses * Before each round, you should display to the user how many guesses s/he has left and the letters that the user has not yet guessed. * Ask the user to supply one guess per round. Make sure to check that the user guesses a letter * The user should receive feedback immediately after each guess about whether their guess appears in the computer's word. * After each guess, you should display to the user the partially guessed word so far. * If the guess is the symbol *, print out all words in wordlist that matches the current guessed word. Follows the other limitations detailed in the problem write-up. ''' # FILL IN YOUR CODE HERE AND DELETE "pass" pass# When you've completed your hangman_with_hint function, comment the two similar# lines above that were used to run the hangman function, and then uncomment# these two lines and run this file to test!# Hint: You might want to pick your own secret_word while you're testing.if __name__ == "__main__": # pass # To test part 2, comment out the pass line above and # uncomment the following two lines. secret_word = choose_word(wordlist) secret_word = 'else' hangman(secret_word)############### # To test part 3 re-comment out the above lines and # uncomment the following two lines. #secret_word = choose_word(wordlist) #hangman_with_hints(secret_word)]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet1(PartB)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet1(PartC)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 1 (PDF) 打卡天数：D04 Part C 作业要求（截取）:Part C: Finding the right amount to save away In Part B, you had a chance to explore how both the percentage of your salary that you save each month and your annual raise affect how long it takes you to save for a down payment. This is nice, but suppose you want to set a particular goal, e.g. to be able to afford the down payment in three years. How much should you save each month to achieve this? In this problem, you are going to write a program to answer that question. To simplify things, assume: Your semi­annual raise is .07 (7%) Your investments have an annual return of 0.04 (4%) The down payment is 0.25 (25%) of the cost of the house The cost of the house that you are saving for is $1M. You are now going to try to find the best rate of savings to achieve a down payment on a $1M house in 36 months. Since hitting this exactly is a challenge, we simply want your savings to be within $100 of the required down payment. In ps1c.py, write a program to calculate the best savings rate, as a function of your starting salary. You should use bisection search to help you do this efficiently. You should keep track of the number of steps it takes your bisections search to finish. You should be able to reuse some of the code you wrote for part B in this problem. Because we are searching for a value that is in principle a float, we are going to limit ourselves to two decimals of accuracy (i.e., we may want to save at 7.04% ­­ or 0.0704 in decimal – but we are not going to worry about the difference between 7.041% and 7.039%). This means we can search for an integer between 0 and 10000 (using integer division), and then convert it to a decimal percentage (using float division) to use when we are calculating the current_savings after 36 months. By using this range, there are only a finite number of numbers that we are searching over, as opposed to the infinite number of decimals between 0 and 1. This range will help prevent infinite loops. The reason we use 0 to 10000 is to account for two additional decimal places in the range 0% to 100%. Your code should print out a decimal (e.g. 0.0704 for 7.04%). Try different inputs for your starting salary, and see how the percentage you need to save changes to reach your desired down payment. Also keep in mind it may not be possible for to save a down payment in a year and a half for some salaries. In this case your function should notify the user that it is not possible to save for the down payment in 36 months with a print statement. Please make your program print results in the format shown in the test cases below. Note: There are multiple right ways to implement bisection search/number of steps so your results may not perfectly match those of the test case. 作业心得PartC的作业，根据以下前提条件，计算如果3年内要付首付，每月最优存款比例： 年薪涨幅是 .07 (7%) 投资年回报率是 0.04 (4%) 首付是总款的0.25(25%) 总款是1百万 有几点需要注意： 需要用到 bisection search 算法 每月存款比例保留小数点后两位，比如7.041%，使用浮点数表示为 0.0741，所以我们可以利用0-10000的整数来做算法计算，最后再转化为float 本次作业学习到以下知识点： 需要用到 bisection search 算法，可以参考以下链接：https://stackoverflow.com/questions/47196917/python-bisection-search-exercise python 在函数外定义变量，默认是全局变量，在函数中默认能够读取，但无法修改，参考：https://www.programiz.com/python-programming/global-keyword 程序逻辑引入了全局变量，显得不太优雅，仍有改善空间。 程序实现的时候，参考了一下连接：https://github.com/iamwhil/6.0001（运行结果与作业中的测试相符）https://github.com/kaizenflow/6.0001-ps1（无法得到正确的结果） 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# 起始年薪annual_salary = 1500000# annual_salary = float(input("Enter the starting salary:"))# 房价total_cost = 1000000# 薪资涨幅semi_annual_raise = 0.07# 首付比例portion_down_payment = 0.25# 存款年化率R = 0.04deep = 0# 首付down_payment = total_cost * portion_down_paymentlast_portion_saved = Falsedef month_counter(current_savings, annual_salary, portion_saved): # 当前月份 month_count = 1 # while loop while True: # 当月情况判断 # 计算当月存款 = 存款 + 月薪*每月薪资存款比例 + 投资回报 current_savings = current_savings + annual_salary/12*portion_saved + current_savings*R/12 # 如果存款 和 首付，相差不到100，也算达成条件 if current_savings &gt;= down_payment: break if month_count % 6 == 0: annual_salary += annual_salary * semi_annual_raise # 月份自增 month_count += 1 return [month_count, current_savings]def bisection_search(portion_saved_rates, annual_salary): global last_portion_saved global deep deep += 1 # 计算中位数，【//】 符合表示除法的商是整数 if len(portion_saved_rates) == 1: return last_portion_saved middle = len(portion_saved_rates) // 2 portion_saved = portion_saved_rates[middle] / 10000 init_current_savings = 0 # 如何计算的月份与预期相等 res = month_counter(init_current_savings, annual_salary, portion_saved) month_count = res[0] current_savings = res[1] # print(portion_saved_rates, month_count, current_savings, portion_saved, abs(current_savings - down_payment)) if month_count == month_count_expect: last_portion_saved = portion_saved_rates[middle] if abs(current_savings - down_payment) &gt; 100: return bisection_search(portion_saved_rates[:middle], annual_salary) else: return portion_saved_rates[middle] elif month_count &gt; month_count_expect: # 计算的月份比期望的大，说明存款比例少了,要提升比例 # print(portion_saved_rates[:middle]) return bisection_search(portion_saved_rates[middle:], annual_salary) else: return bisection_search(portion_saved_rates[:middle], annual_salary)portion_saved_rates = range(0, 10000)month_count_expect = 36res = bisection_search(portion_saved_rates, annual_salary)if res is False: print("It is not possible to pay the down payment in three years.")else: print("Best savings rate: &#123;&#125;".format(res/10000)) print(res/10000) print("Steps in bisection search: &#123;&#125;".format(deep))]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet1(PartB)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet1(PartB)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 1 (PDF) 打卡天数：D03 Part A 作业要求（截取）:Part B: Saving, with a raise Background In Part A, we unrealistically assumed that your salary didn’t change. But you are an MIT graduate, and clearly you are going to be worth more to your company over time! So we are going to build on your solution to Part A by factoring in a raise every six months. In ps1b.py, copy your solution to Part A (as we are going to reuse much of that machinery). Modify your program to include the following Have the user input a semi-annual salary raise semi_annual_raise (as a decimal percentage) After the 6 th month, increase your salary by that percentage. Do the same after the 12 th month, the 18 th month, and so on. Write a program to calculate how many months it will take you save up enough money for a down payment. LIke before, assume that your investments earn a return of r = 0.04 (or 4%) and the required down payment percentage is 0.25 (or 25%). Have the user enter the following variables: The starting annual salary (annual_salary) The percentage of salary to be saved (portion_saved) The cost of your dream home (total_cost) The semi­annual salary raise (semi_annual_raise) 作业心得PartB的作业其实和PartA的整体思路差不多，主要是增加了一个变动收入，没6个月加薪 写一个程序用于计算 需要多少个月储蓄才够首付，大多数变量都需要float类型，所以需要将用户的输入转化为float，程序需要用户输入以下变量：: 一开始的年薪 (annual_salary) 每月存款的比例 (portion_saved) 房子的价钱 (total_cost) 提薪的比率（semi_annual_raise） 整体的思路就是做一个循环，每个迭代就是一个月，判断当月 的存款是否大于等于首付。存款由三部分组成： 已有存款 月薪按比例存款；月薪每6个月有涨幅（这里是重点，原文是after 6th month，也就是第7个月薪资变动才生效，而不是第6个月） 每月投资回报 程序代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 起始年薪# annual_salary = 75000annual_salary = float(input("Enter your annual salary:"))# 每月薪资存款比例# portion_saved = .05portion_saved = float(input("Enter the percent of your salary to save, as a decimal:"))# 房价# total_cost = 1500000total_cost = float(input("Enter the cost of your dream home:"))# 薪资涨幅# semi_annual_raise = 0.05semi_annual_raise = float(input("The semi­annual salary raise:"))# 首付比例portion_down_payment = 0.25# 存款年化率r = 0.04# 当前存款current_savings = 0# 当前月份month_count = 1# 首付down_payment = total_cost * portion_down_payment# while loopwhile True: # 当月情况判断 # 计算当月存款 = 存款 + 月薪*每月薪资存款比例 + 投资回报 current_savings = current_savings + annual_salary/12*portion_saved + current_savings*r/12 # print("第&#123;&#125;个月，薪水&#123;&#125;，存款&#123;&#125;，首付&#123;&#125;".format(month_count, annual_salary, current_savings, down_payment)) if current_savings &gt;= down_payment: print("Number of months: &#123;&#125;".format(month_count)) break if month_count % 6 == 0: annual_salary += annual_salary * semi_annual_raise # 月份自增 month_count += 1]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet1(PartA)]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet1(PartA)%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 1 (PDF) 打卡天数：D02 Part A 作业要求（截取）:Part A: House Hunting You have graduated from MIT and now have a great job! You move to the San Francisco Bay Area and decide that you want to start saving to buy a house. As housing prices are very high in the Bay Area, you realize you are going to have to save for several years before you can afford to make the down payment on a house. In Part A, we are going to determine how long it will take you to save enough money to make the down payment given the following assumptions: Call the cost of your dream home total_cost. Call the portion of the cost needed for a down payment portion_down_payment. For simplicity, assume that portion_down_payment = 0.25 (25%). Call the amount that you have saved thus far current_savings. You start with a current savings of $0. Assume that you invest your current savings wisely, with an annual return of r (in other words, at the end of each month, you receive an additional current_savings*r/12 funds to put into your savings – the 12 is because r is an annual rate). Assume that your investments earn a return of r = 0.04 (4%). Assume your annual salary is annual_salary. Assume you are going to dedicate a certain amount of your salary each month to saving for the down payment. Call that portion_saved. This variable should be in decimal form (i.e. 0.1 for 10%). At the end of each month, your savings will be increased by the return on your investment, plus a percentage of your monthly salary (annual salary / 12). Write a program to calculate how many months it will take you to save up enough money for a down payment. You will want your main variables to be floats, so you should cast user inputs to floats. Your program should ask the user to enter the following variables: The starting annual salary (annual_salary) The portion of salary to be saved (portion_saved) The cost of your dream home (total_cost) 作业心得光看懂英文作业已经蛮吃力了，哈哈，简化作业说明如下： 买房子的总费用为 total_cost 首付（down payment）为25%, portion_down_payment = 0.25 存款为 current_savings，从0开始 存款有投资，年回报率（an annual return）为r（0.04），所以每月额外收入为 current_savings*r/12 年薪为 annual_salary 从每月薪资中，固定比例用于首付，这个比率设为 portion_saved 每个月的收入来源，主要是 投资回报 + 每月工资 monthly salary（annual salary / 12） 写一个程序用于计算 需要多少个月储蓄才够首付，大多数变量都需要float类型，所以需要将用户的输入转化为float，程序需要用户输入以下变量：: 一开始的年薪 (annual_salary) 每月存款的比例 (portion_saved) 房子的价钱 (total_cost) 整体的思路就是做一个循环，每个迭代就是一个月，判断当月 的存款是否大于等于首付。 存款由三部分组成： 已有存款 月薪按比例存款 每月投资回报 程序代码# 起始年薪 # annual_salary = 120000 annual_salary = float(input("Enter your annual salary:")) # 每月薪资存款比例 # portion_saved = .10 portion_saved = float(input("Enter the percent of your salary to save, as a decimal:")) # 房价 # total_cost = 1000000 total_cost = float(input("Enter the cost of your dream home:")) # 首付比例 portion_down_payment = 0.25 # 存款年化率 r = 0.04 # 当前存款 current_savings = 0 month_count = 1 # 首付 down_payment = total_cost * portion_down_payment while True: # 计算当月存款 = 存款 + 月薪*每月薪资存款比例 + 投资回报 current_savings = current_savings + annual_salary/12*portion_saved + current_savings*r/12 if current_savings &gt;= down_payment: print("Number of months: {}".format(month_count)) break # 月份自增 month_count += 1]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1901090022-MIT60001-ProblemSet0]]></title>
    <url>%2FMIT60001%2F1901090022-%E8%87%AA%E5%AD%A6%E8%AE%AD%E7%BB%83%E8%90%A5-MIT-Python%E8%AF%BE-ProblemSet0%2F</url>
    <content type="text"><![CDATA[打卡记录 学号：1901090022 学习课程：Introduction to Computer Science and Programming in Python 学习内容：Problem Set 0 (ZIP - 2.0MB) 打卡天数：D01 作业要求（简述）:Write a program that does the following in order: Asks the user to enter a number “x”; Asks the user to enter a number “y”; Prints out number “x”, raised to the power “y”. Prints out the log (base 2) of “x”. Use Spyder to create your program, and save your code in a file named ‘ps0.py’. An example of an interaction with your program is shown below. The words printed in blue are ones the computer should print, based on your commands, while the words in black are an example of a user’s input. The colors are simply here to help you distinguish the two components. 1234Enter number x: 2 Enter number y: 3 X**y = 8log(x) = 1 作业心得根据提示，本章作业涉及的知识点如下： print / input 函数的使用，可以参考以下文章 input()函数 print()函数 python中的基础数学运算，pow函数; math库的math.pow/log2函数 pow()函数 math.log2()函数 math.pow()函数 numpy库的log2函数 https://docs.scipy.org/doc/numpy/reference/generated/numpy.log2.html 程序的实现过程中，遇到几点需要注意的： input函数返回的是str类型，需要通过int函数转化才能进行运算，否则会报错 TypeError: unsupported operand type(s) for ** or pow(): ‘str’ and ‘int’” 一般的数据计算，math库也足够了，numpy提供了更多更方便的函数 程序代码1234567891011import mathimport numpy# 因为要参与计算，所以需要使用int函数来转化x = int(input("Enter number x:"))y = int(input("Enter number y:"))# 使用内置函数和math库来实现程序print("x**y = &#123;&#125;\nlog(x) = &#123;&#125;".format(pow(x, y), int(math.log2(x))))# 使用numpy库来实现程序print("x**y = &#123;&#125;\nlog(x) = &#123;&#125;".format(numpy.power(x, y), int(numpy.log2(x))))]]></content>
      <categories>
        <category>MIT60001</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MIT</tag>
        <tag>学习打卡</tag>
      </tags>
  </entry>
</search>
